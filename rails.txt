{GENERATING}

        (to generate a model or controller)
    rails generate
        - rails generate controller ControllerName  method1 method2
                e.g. rails generate controller StaticPages home help
        - rails generate model ModelName colname:datatype colname:datatype
                e.g. rails generate model User name:string email:string 
        - rails generate migration NameTheMigration

        (to reverse generated model or controller)
    rails destroy 
        - rails destroy controller ControllerName method1 method2
                e.g. rails destroy controller StaticPages home help
        -rails destroy model ModelName
                e.g. rails destroy User 
                    NOTE: ONLY model can omit arguments

{RAILS SERVER}

        (opening multiple rails app locally)
    rails server -p 3001
        - opens up a rails server on a different port!
        i.e. rails http://localhost:3001

{ROUTING}

    helper methods
        - automatically generated and correspond to route names
        e.g. edit_post_path(3) => edit_post_path(:id)
            :id is in the params hash 

    _path VS _url

        _path 
            - generates JUST the path portion
            e.g. /post/3/edit

        _url 
            - generates WHOLE url 
            e.g. lazzyreader.com:80/post/3/edit

    root route
        root to: "kittens#index" 
            OR 
        root 'kittens#index'
        -directs to KITTENS controller and INDEX action

    RESTful routes 
        7 FUNDAMENTAL routes
        index - GET
        show  - GET
        edit  - GET
        update- PUT
        new   - GET
        create- POST
        destroy- DELETE
    
    MUST have ALL to follow RESTful 
            mandatory for each resource 
        get    "/posts",          to: "posts#index"
        get    "/posts/:id",      to: "posts#show"
        get    "/posts/new",      to: "posts#new"
        post   "/posts",          to: "posts#create"  # usually a submitted form
        get    "/posts/:id/edit", to: "posts#edit"
        put    "/posts/:id",      to: "posts#update" # usually a submitted form
        delete "/posts/:id",      to: "posts#destroy"

            OR 
        resources :posts
            -creates the 7 routes for post in application
        ( LITERALLY MAKES ALL 7 ABOVE WITH ONE METHOD )
        
        ^ 5 paths and helpers
        /posts           posts_path
        /posts/:id       post_path(:id)
        /posts/new       new_post_path
        /posts/:id/edit  edit_post_path(:id)

        resources :ControllerName
                i.e.   resources :posts

                resources :posts, only: [:index, :show]
                    or 
                resources :posts, except: [:index]

                    - to pick which requests out of the 7
                        only or omitance/except
            
        singular resources
         ^are plural resources

         resource :photo VS resources :photos

         ^ creates 
            /photo/new    new_photo_path
            /photo/edit   edit_photo_path
            /photo        edit_photo_path

            NOTE: no id paths, since theres only 1

    Name Spaces 
        - a way to route to special paths 
            NOTE: like admin articles 
        e.g. 
            namespace :admin do
                resources :articles, :comment
            end
            (several ways of writing this: search up if needed)
        creates Admin::ArticlesController
            -admin module makes a

            /admin    -infront of the 5 paths
                i.e. /admin/articles      GET
                     /admin/article/new   GET 
                      ..etc
        MUST put under
            app/controllers/admin   directory
    
    Nested resources
            -creates a relational path
                so to get ad, must have magazine path
        resources :magazines do 
            resources :ads 
        end

        creates such as 
        GET     /magazines/:magazine_id/ads         ads#index
                  helper: magazine_ads_path
        GET     /magazine/:magazine_id/ads/new      ads#new
                  helper: new_magazine_ad_path
        POST    /magazine/:magazine_id/ads          ads#create
                  helper: magazine_ad_path
        GET     /magazine/:magazine_id/ads/:id/edit ads#edit
                  helper: edit_magazine_ad_path
        etc... 
            NOTE: all links will have /magazine infront
            because of relational relationship
                i.e. 
                # each magazine has it own ads
                # and an ad MUST belong to a magazine
                class Magazine < ApplicationRecord
                    has_many :ads
                end
                
                class Ad < ApplicationRecord
                    belongs_to :magazine
                end

    ADD member routes, collection routes
        {MEMBER}
        - adding another route to the usual rest routes
         i.e. index,show,edit,update,delete,new,create

        resources :photos do
            member do
                get 'preview'
            end
        end
            - adds this path to photos routes
            i.e. /photos/1/preview
                NOTE: only apply with get requests to preview
                (can add other request types to new member)
            # AND must add preview action to PhotoController
        
        {COLLECTION}
        - adding another routes to the usual rest toute
        but without having it linked to specific id

        resources :photos do
            collection do
                get 'search'
            end
        end
            -adds this path to photos routes
            i.e. /photos/search
                NOTE: applies to get request
                -routes to search action of PhotoController
            
    Shallow Nesting ***should figure out why********
            would need multiple parameters for paths
            e.g. article_comment_path(@article, @comment)
                    or 
                 url_for([@article, @comment])
                 -this gets the specific comment for the article
        
        BASICALLY!

        1.  INSTEAD OF: 
                resources :articles do
                    resources :comments
                end 

        2.  ITS DOING: 
                resources :articles do
                    resources :comments, only: [:index, :new, :create]
                end
                resources :comments, only: [:show, :edit, :update, :destroy]
            
        3.  SUM IT UP INTO:
                resources :articles do
                        resources :comments, shallow: true
                end
                    OR 
                shallow do
                    resources :article do
                        resources :comments
                    end
                end
            (does the same thing as 2!)
        why?      
            only nests the the parts that identify the 
            relationship between the 2 resources!
                    heh?
            show is linked to index, create and new
            edit is linked to create,and new
            update is linked to create,and new
            destroy is linked to create, and new

    Segments (static, dynamic, bound)
        - different paths! styles
        
        Static Segment
            get 'photos/:id/with_user/:user_id', to: 'photo#show'
        with_user: is static Segment

        Dynamic Segment
            get 'photos/:id/:user_id, to 'photo#show'
        :id && :user_id: are dynamic Segments, they change

        Bound Segment
            get 'photos(/:id)', to: :display
        (/:id): is bound, its option  
        
        Query string
            # everything after '?' in the url
            get 'photos/:id', to: 'photo#show'
                works with:
                /photos/1?user_id=2
            Query is user_id=2
            similar to: /photo/:id/:user_id
                       /photo/1/2

    Defaults 
        -setting defaults in the routes

        get 'photo/:id', to: photos#show', defaults: { format: 'jpg' }
        # setting photos that display to users to jpg

        # setting default for a resource
        defaults format: :json do
            resources :photos
        end

        CANT DO       #format defaults
        /photos/1?format='json'
            security purposes NOT ALLOW TO override 
        CAN DO        #dynamic segments 
        /photos/1?user_id=2 
            OR
        /photos/1?id=1

            FORMAT REQUEST OPTIONS
        get 'pages', to: 'pages#show', format: false
            #format not mandatory
        get 'pages', to: 'pages#show', format: true
            #format is mandatory

    CONSTRAINTS 
        go back to ruby guide to read up on it again
            guides.rubyonrails.org 
        1. Segment contrainsts 3.8
        2. Request-Based Contraints 3.9
        3. Advanced Constraints 3.10 
    
    REDIRECTING
        go back to ruby guide to read up on it again
        (Its not that big of a thing it seems)

    Globbing and Wildcard Segments
        Globbing VS Wildcard
            # basically the same thing, just 
            # on is at the end and other in 
            # all over i.e. middle, front, etc.
            
            Globbing
        get 'photos/*other', to: 'photos#unknown'
            - the * on the other allows path to match: 
            /photos/12 or /photos/long/path/to/12
            params[:other] = "12"
                OR
            params[:other] = 'long/path/to/12'

            Wildcard
        get 'books/*section/:title', to: 'books#show'
            -matches:
            /books/some/section/last-words-a-memoir
            params[:section] = 'some/section'
            params[:title] = 'last-words-a-memoir'

    Custom routes

        get '/somepath', to: 'somecontroller#someaction
            -pick the path and controller of ones choice

stopped 3.13 

{CONTROLLERS}
    7 main controllers made which  
        correspond to the 7 actions of request

        1. index     GET
        2. show      GET
        3. new       GET
        4. create    POST
        5. edit      GET   
        6. update    PUT/'PATCH'
        7. destroy   DELETE

    Multiple if a params hash

        # returning hash parameters
        for the html to return parameters in a hash
        <form accept-charset="UTF-8" action="/clients" method="post">
            <input type="text" name="client[name]" value="Acme" />
            <input type="text" name="client[phone]" value="12345" />
            <input type="text" name="client[address][postcode]" value="12345" />
            <input type="text" name="client[address][city]" value="Carrot City" />
        </form>

    params[:client] =>  {   "name" => "Acme", 
                            "phone" => "12345", 
                            "address" => { 
                              "postcode" => "12345", 
                              "city" => "Carrot City" 
                            } 
                        }. 

        MUST "white list" 

        def client_params 
            params.require(:client).permit(:name,:phone,:address)
        end

        # params hash parameters that have multiple 
        # parameters need to be permitted
        FOR SECURITY 
    
    Flash 
        1. flash[:notice]
            # uses flash message in next request
            e.g. flash[:notice] = 'Success logging out!'

        2. flash.now[:alert]
            #uses flash messsage in the same request
            e.g. flash.now[:error] = 'Input Error!'
        
        3. flash.keep
            # keeps flash message for another request 
    
        Extra
    <%      flash.each do |name, meg|          %>
    <%=          content_tag :div, msg, class:name     %>
    <%      end              %>   

        # will display any flash message made into layout
        # automatically

        Remember! 
            flash is a HASH called "flash hash" 
                it puts all flashes into this hash
                then uses them based on the method!

                1. .now shows on the current rendered screen
                2. flash goes on the redirect to the next pages
                    so it stays in the hash until the next pages
                3. .keep stays in the hash until theres no keep 
                     i guess 

{VIEWS}

    View partials
        # common and repetive parts get put into partials
        # which are injected into other files for reuse
        
            To render partial in html forms
        <%= render :partial 'form' %> 
            or 
        <%= render 'form' %>

        partial forms start with underscore
        e.g. _form.html.erb
             _user_form.html.erb
             etc..
            
    Passing local Varialbles to partials
        <%= render "folder/the_partial", 
            :locals => { :user => user }
        %> 
    
        NOTE: its expected to pass in the variables 
        we wish to use in partials 
        -its apparently bad coe to expect an instance
        variable like @user to be there in the partial 
        all the time

        - which makes sense i guess, if you want to put
        other values in the form 
        i.e. user vs businesses
            but using the same form for registration!

    Helper method
        #link_to  
            - links page to a path
        
        1. INSTEAD OF: 
            <a href= 
                "<%= user_path %>" 
            > 
                "See All Users" 
            </a>

        2. DO THIS: 
            <%= link_to "See All Users", users_path %>

    Render actions template

        1. in the current controller 
            render 'show'
            render action: 'show'
                OR 
            render :show
            render action: :show

            NOTE: looks in the current controller folder
        
        2. in another controller
            render 'products/show'
                OR 
            render template: 'products/show'

            NOTE: looks inside the products controller folder
            then renders the show template there!

        3. render file in the system 
            render file: '/path/to/ware_house_app/current/app/views/products/show'
    
    Type of render 

        1. :content_type
                    # use this type when showing the page
                render file: filename, content_type: 'application/rss'

        2. :layout
                  # use special_layout for this action
                render layout: 'special_layout'
                  # dont use a layout at all 
                render layout: false
        3. :location
                  # use this lcoation for http header
                render xml: photo, location: photo_url(photo)
        4. :status
                  # change default response to:
                render status: 500
                render status: :forbidden
                    i.e. render status: 403
        5. :formats
                  # choosing format or error occurs 
                render formats: :xml
                    # must be these options
                redner format: [:json, :xml]

    Choosing Layouts for actions or controller
        # must put layout 'layoutChoice'

        e.g. 
        1.  # pick layouts/inventory.html.erb
            # as the layout for this controller
            # instead of layouts/application.html.erb
            class PhotoController << ApplicationController
                layout 'inventory'
            end
        2.  # pick layouts/inventory.html.erb
            # as the layout for ALL controllers
            # instead of layouts/application.html.erb
            class ApplicationController < ActionController::Base
                layout 'inventory'
            end 

        3. exception to layout 
                layout 'inventory', except: [:index, :rss]
                # the index and rss method would use the 
                # default application.index.erb layout
        
        4. defer the choice of layout until request processed
            # to defer the layout for a request
            # must use a symbol 
            e.g.
            layout :inventory
            # then use logic to determine when to use it

            def inventory
                @current_user.special? ? 'special' : 'product'
            end
            # not sure how this works just yet, but im assuming
            # that because its true it applies to the method 
            # chosen. if its not true then doesn't apply
            # IF TRUE WORKS FOR ANY METHOD IN THE CONTROLLER

    Redirect 
        redirect_to VS redirect_back
        
        1. Using the redirect_to     
            #redirect_to a relative path or url  
                redirect_to photos_path 
                    and 
                redirect_to photos_url 

                #same redirect_to /photos
                    and 
                #same redirect_to https://www.example.com/photos
        
                    OR 
                redirect_to edit_photo_path
                #same redirect /photo/:id/edit 

            # change status code
            redirect_to photos_path, status: 301
            default it 302, tempoary
        2.  redirect back to path just came from 
             #redirect_back with a fall back path
                redirect_back(fall_back_location: root_path)

            NOTE: this doesn't always work if the browser
            doesn't store the previous path in the 
            HTTP_REFERER header, so there must be 
            default. Just better to use redirect_to

    Header reponses
        Find all the numbers or symbols: https://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option
       
        1. One header response
            head :bad_request 

            #same head 400 

        2. Multiple header responses

            head :created, location: photo_path(@photo)

        # unlike redirect_to or render 
        # header responses sends no body 
        # meaning it sends no html, or content 
        # so it only sends back the request status
        # unless otherwise said like the 
        # "location: photo_path(@photo)"
        # that sends in the contents of that path 
        # with the status code 

    ASSET TAG HELPERS 
        there are 6 tags
            top 3 usually in headers 
        1. link to feeds 
            *****not sure what that means yet*****
            
            three options available for the tags   
                a. :rel - default 'alternate'
                b. :type 
                c. :title 

            auto_discovery_link_tag 
            e.g. 
                auto_discovery_link_tag( :rss,
                        {action: 'feed'}, 
                        {title: 'RSS Feed'}
                )
            something link(in html): 
            <link rel="alternate" type="application/rss" title="RSS feed" href="http://www.somesite.com/file/rss.php" />

        2. links a javascript file

            javascript_include_link_tag
            e.g.
            a.  # include one file 
                javascript_include_link_tag 'main'
            b.  # include multiple files
                javascript_include_link_tag 'main', '/photos/columns'

        3. links a style sheet 
            2 options to pick for stylesheet
                rel:    default= 'stylesheet'
                media:  default= 'media' 

            stylesheet_link_tag
            e.g. 
            a.  # include one file
                stylesheet_link_tag 'main'   
            b.  # include mutiple 
                stylesheet_link_tag 'main', 'photos/columns'

        4. link to image file 
            # MUST specify image extension 
            # i.e. .png, .jpg
            
            options to pick for image 
                alt:   -alt for black image (description)
                id:  -tag id of choice
                class:  -class tag of choice
                size:50x20 {widthxheight} - image size of choice
            image_tag
            e.g. 
                # added hash of html options 
                image_tag 'header.png', {height: 45}
                # not add hash 
                image_tag 'header.png', alt: 'Go home', id: 'HomeImage', class: 'nav_bar'
        
        5. link to video_tag
            options for video tags
                all image tag options ^ 
                poster: 'image_name.png', provides image to put in place of video before it starts (thumbnail)
                autoplay: true/false, starts playing on page load 
                loop: true/false, loops video once it gets to the end
                controls: true/false, provides browser supplied controls for user to interact with video
                autobuffer: true/false, video  will preload the file for user on pageload

            video_tag 
            e.g. 
                video_tag 'movie.ogg' 
                #html like
                <video src= '/videos/movie.ogg' />
                
                # tag multiple videos (playlist?)
                video_tag ['trailer.ogg', 'movie.ogg']

                html like:   (seems like a playlist to me)
                <video> 
                    <source src='/video/trailer.ogg'>
                    <source src='/video/movie.ogg'>
                </video>

        6. link to audio tags
            options for tag
            class:
            id:
            autoplay: true/false, starts playing audio on page load
            controls: true/false, browser supplied controls for user interaction
            autobuffer: true/false, auto preloads on pageload
            
            audio_tag
            e.g. 
                audio_tag 'music.mp3' 

    USING YIELD IN THE LAYOUTS 
        named yields VS unamed yields 

        1. unname yields 
            -always renders body of the views
            # like any normal yield
            <html>
                <head>
                </head>
                <body>
                    <%= yield %>
                </body>
            </html>

        2. name yields 
            # allows multiple yields in one layout 

            html>
                <head>
                    <%= yield :head %>
                </head>
                <body>
                    <%= yield %>
                </body>
            </html>

            using content_for method 
            # can insert into name yield while body
            # goes into unamed yield
            e.g. 
            # the title goes into name yield :head ^ IN HEAD TAG 
            <% content_for :head do %>
                <title>A simple page</title>
            <% end %>
            
            # unamed yield gets rest of content IN BODY TAG
            <p>Hello, Rails!</p>

    PARTIALS 
        render partial 

        user render in view template (knew about this)     
        <%= render 'partial' %>
        don't have to put the underscore

{ASSET PIPELINE}

    -Asset pipeline compresses files so they run all at onces
     when users call the site 
     i.e. javascript, css, etc. files 

    SUMMARY (based on what ive gathered)
    # purpose of this pipe line is to combine the multiple files
    # in the application into one massive file to make it faster
    # in production so there are no multiple page loads, just one.
    # by using the "sprocket" gem, it uses the minifest files to 
    # gather all the pages into the main file to launch into 
    # production
    # files in app/asset, lib/assets and vendor/asset all come
    # to one location to get launched into prodution minifest 
    # files 
     read again: 
     https://guides.rubyonrails.org/asset_pipeline.html

     ** i don't have a complete understanding just yet** 
    
{TESTING}
    test_helper in rails 

    Commands
        1. get "path"
        2. assert_templete 'path/to/directory/file'
            relative to the view folder
        3. assert_select 
                selects elements in the html 
            e.g. assert_select "a[href=?]", root_path, count:2
                 OR 
                 assert_select "title", "Help | Ruby on Rails .."
            1. inserts root path in "?" to select the link
            2. checks the page of 2 links of the selected link
               with "count"  
        4. assert_response 
            - checks the status code of the reponse header 
                of the page incoming
            e.g. assert_response :success
                    or 
                 assert_response 200
                 # check guide for all the response symbols

        Options for assert_select
            Code                                       Matching html 
        assert_select "div"	                        <div>foobar</div>
        assert_select "div", "foobar"	            <div>foobar</div>
        assert_select "div.nav"	                    <div class="nav">foobar</div>
        assert_select "div#profile"	                <div id="profile">foobar</div>
        assert_select "div[name=yo]"	            <div name="yo">hey</div>
        assert_select "a[href=?]", '/', count: 1	<a href="/">foo</a>
        assert_select "a[href=?]", '/', text: "foo"	<a href="/">foo</a>

{DATABASE MIGRATIONS}

        (migrating model info to database)
    rails db:migrate 
        - migrating to database

        (to undo a single migration)
    rails db:rollback
        - the most recent migration will be undone
        e.g. migrated and created 4 new collumns but forgot 
            to add the user email. you can just db:rollback

        (to rollback to the beginning)
    rails db:rollback VERSION=0    
        - to undo all migrations to the database 
        - TOTAL RESET 
        NOTE: putting 1,2,etc in VERSION migrates to that VERSION
        e.g. to roll back to specific version 

        rails db:migrate VERSION=20080906120304 

        reails db:rollback STEP=3

            NOTE:  number is the prefix of migration file
            i.e. 20080906120304_create_product_table.rb
            i.e. 3 is number of migrations to roll back
    rails db:migrate RAILS_ENV=test 
        #run test in specific environment

{MODELS}
    Active record
        Validations Active Record 
        # validates model state before saving to data base
        # state of object is validated before entering database

            # checks if the entry fits the constraint
                validates :name, presence: true
            e.g. 
                # name can't be null
                class User < ApplicationRecord
                    validates :name, presence: true
                end

        valid? VS invalid? 
                # checks if it passes validation
                .messages checks output 
                e.g. 
               1. User.create(name: "John").valid? => true
               2. User.create(name: nil).valid => false 
                # 2 wont save/persist in the database
                # 1 will 

            NOTE: .update and .save 
                # when putting data on the database goes through to
                # check for the validated parameter
                will return error if it has the ! called the bang
                i.e. "!"
                create!
                update!
                save! => ActiveRecord::RecordInvalid: Validation failed: name can't be blank
        
        .new_record? 
            checks if entry is already in database 
            end returns true or false 
            Person.new(name: "John").new_record? => true
            after .save, this will be false

        errors Validation errors 
            base message
                # adds to any error
                errors[:base] << "error message"

            .errors[] VS .errors.details[]
            errors array
            1.      Person.new.errors[:name].any? => false
                # checks if there are errors with the 
                # instance of the person object or not 
                # in this canse there isn't 

                Person.new.errors.full_messages 
                # same thing (all errors tho not just name)

            2.      Person.errors.details[:name] => [{error: :blank}]
                # if theres an error, it gets the details of that 
                # error 

            3.      errors.add()
                e.g.
                class Person < ApplicationRecord
                    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
                        OR another way
                    errors.add(:name, :invalid_characters, not_allowed: "!@#%*()_-+=")
                end

                person = Person.create(name: "!@#")
 
                person.errors[:name]
                # => ["cannot contain the characters !@#%*()_-+="]
                
                person.errors.full_messages
                # => ["Name cannot contain the characters !@#%*()_-+="]
        

        Validation Helpers
            guide: https://guides.rubyonrails.org/active_record_validations.html 

            1. acceptance
            2. validates_associated
            3. confirmation
            4. exclusion
            5. format
            6. inclusion 
            7. length
            8. numericality
            9. presence
            10. absence
            11. uniqueness
            12. validates_with
            13. validates_each

            1. acceptance 
                # used for checkbox on UI was checked 

                a. must be checked to move on 
                    e.g. 
                    validates :terms_of_service, acceptance: true 
                
                b. message
                    #is not nil sends a message if nil does not 
                    e.g.
                    validates :terms_of_service, acceptance: {message: 'must be abided'}

                c. accept
                    # specifies what constitutes as accept
                        # must get a yes to validate acceptance
                    validates :terms_of_service, acceptance: {accept: 'yes'}

                        # if acceptance field is in database 
                        # must put true in field
                        e.g.
                    validates :terms_of_service: {accept: ['TRUE', 'accepted']}

            2. validates_associated 
                    # if model has association it also validates them
                    i.e. if something belongs to the model 
                         and needs validation 

                    e.g. 
                        # validates all the books before
                        # creating the library
                        # persisting to the database

                        class Library < ApplicationRecord 
                            has_many :books
                            validates_associated :books
                        end

            3. confirmation
                    # validates that the entry matches confirmation field

                    a. #validate that email matches _confirmation field
                      validates :email, confirmation: true
                    
                      checks the :email_confirmation field

                        possible view templates 
                            (I THINK!)
                            :person in value of the view also class/model
                            :email is in place of the name also column
                        
                        <%= text_field :person, :email %>
                        <%= text_field :person, :email_confirmation %>

                    b. remove case sensitivity
                        #default is true
                        ,confirmation: {case_sensitive: false}

            4. exclusion
                    # picks specific values that wont be 
                    # allowed when validating the input

                    e.g. validates :subdomain, exclusion: { in: %w(www us ca jp)
                            message: "%{value} is reserved" }
            5. format 
                    # checks for specific values in entry

                    # all entries must be letters
                    e.g.
                    validates :legacy_code, format: {with: /\A[a-zA-Z]+\z/,
                                message: "only allows letters" }

            6. inclusion
                    #opposite of exclusion 

                    # picks specific values that will be allowed when 
                    # validating the input

                    e.g. validates :size, inclusion: { in: %w(small medium large),
                            message: "%{value} is not a valid size" } 

            7. length 
                    validates :bio, length: {maximum: 2}
                    validates :bio, length: { maximum: 500 }
                    validates :password, length: { in: 6..20 }
                    validates :registration_number, length: { is: 6 }
                    
                    e.g. example of error message
                    validates :bio, length: {maximum: 1000,
                        too_long: "%{count} characters is max allowed}

                    # checks character length of entry
                        
                        options Constraints
                        :minimum       - given min
                        :maximum       - given max
                        :in or :within - given a range
                        :is            - picking exact length
                    
                        Error option
                        :too_long   - when max is given
                        :too_sort   - when min is given
                        :wrong_length   -either max or min
                
            8. numericality 
                # checks if all entry values are numbers
                
                e.g. 
                # checks if number but with one space for character
                # in the front, i think for money i.e. $5000.00
                validates :point, numericality: true

                # checks for only number integer 
                validates :point, numericality: {only_integer: true}

                    option Constraints
                    :greater_than              - >
                    :greater_than_or_equal_to  - >=
                    :equal_to                  - ==
                    :less_than                 - <
                    :less_than_or_equal_to     - <=
                    :other_than                -must be any other
                    :odd                       -must be odd number
                    :even                      -must be even number
                    :allow_nil                 -allow nil values 
                    
                    NOTE: numericality doesn't allow nil values by 
                    default
                
            9. presence
                    # checks if entry exists and not nil/empty
                    
                    e.g. 
                    # checking multiple entries
                    validates :name, :login, :email, presence: true

                    # validates associated records who presence are required
                    class Order < ApplicationRecord
                        has_many :line_items, inverse_of: order
                    end
                        # has many so that means line_items belong to 
                        order
                        i guess it validates in they are there

            10. absence
                    # checks if entry is absent or not there 
                    # must be whitespace or empty string

                        same methods as presence accept absence is there

            11. uniqueness 
                    #makes sure that entry is unique in database

                    e.g.
                    a.  # makes sure given entry is unique
                        # by searching entire database for it 
                        
                        validates :email, uniqueness: true

                    b.  # place a constraint on the search 
                        :scope
                            # checks based on year only not all columns
                        
                        class Holiday < ApplicationRecord
                            validates :name, uniqueness: {scope: :year,
                                message: "should happen once per year"}
                        end 
                        NOTE: in this case it is looking at holidays
                        which would have a name that is ALWAYS associated
                        with a specific date of the year
                            # so it seems to look at names based on year
                            like 2010 checks the names, 2011 checks, etc.
                    
                    c.  change case sensitivity

                        # the search is not case sensitive
                    validates :name, uniqueness: { case_sensitive: false}

            12. validates_with
                        -validates with another model
                    # look at guide for details 

            13. validates_each 
                        - validates mutiple parameter
                        using a block
                     #look at guide for details 
            
        raising validation failed message

            strict
                e.g.
                validates :name, presence: {strict: true}
                if valid, no message
                if not => ActiveModel::StrictValidationFailed: Name can't be blank

        CONDITIONAL Validations
            (guid is at the beginning of validation section)
            :if 
                can use a Proc wit these
                # check guide on if statement for validation
            
            :unless 
                # check guide 
                can even use a block

            with_options
                allows the validation of multiple parameters
                e.g. 

                with_options if: :is_admin? do |admin|
                    admin.validates :password, length: { minimum: 10 }
                    admin.validates :email, presence: true
                end

        Validated methods (one that persist to the database)
         # some methods skip validation 
         # others do not skipp validation 

        1. Doesn't skip 
                create
                create!
                save
                save!
                update
                update!
        
        2. Skips Validation (user with caution)
                decrement!
                decrement_counter
                increment!
                increment_counter
                toggle!
                touch
                update_all
                update_attribute
                update_column
                update_columns
                update_counters
                .save(validate: false)
         
    Seed data 
        # i guess literally "seeding" the database data
        - can use use the file to set up initial data 
        - when data base is created  
        # setting up the database of a black application 
        # in a "clean" way 
            # user before database setup 
                run= rails db:seed 
        # create 5 rows of data right adter the database creation
        e.g. 
            5.times do |i|
                Product.create(name: "Product ##{i}", 
                    description: "A product. ")
            end 
    
    Looking at old Migrations    
        db:migrate:status

        # allows you to view deleted files
        # and current file 
        # has up, down notation

    CRUD Database
        1. Create 
            -creating values inside database rows
            a. Create data with a hash/without hash
                .create VS .new
                user = User.create(name: "David", occupation: "Code Artist")
                    OR  
                user = User.new(name: "David", occupation: "Code Artist")
                user.save 
                    OR 
                user = User.new
                user.name = "David"
                user.occupation = "Code Artist" 
                user.save 
                NOTE: using .new requires .save to commit to database
            b. using a block
                user = User.new do |u|
                        u.name = "David"
                        u.occupation = "Code Artist"
                       end 
                user.save
                    OR 
                user = User.create do |u|
                        u.name = "David"
                        u.occupation = "Code Artist"
                       end 
                
                Analogous SQL
                INSERT INTO users (name, occupation) 
                VALUES ("David", "Code Artist");

        2. Read 
            - retriving/ reading database information
            # return collection of all user objects
                users = User.all

            # return first user
                users = User.first

            # return last user 
                users = User.last
            
            # return first user name David
                david = User.find_by(name: 'David')

            # return users named David who are Code Artists
            # and sort by created_at in reverse chronological order
                users = User.where(name: 'David', occupation: 'Code Artist'
                        ).order(created_at: :desc)
                        
                        Analogous is SQL (I think)
                        SELECT * FROM users 
                        WHERE name= 'David' 
                        AND occupation= 'Code Artist'
                        ORDER BY created_at DESC;
        
        3. Update 
            - changing data in the data base

            # find first 'David's and change all 'David's to 'Dave'
                user = User.find_by(name: 'David')
                user.name = 'Dave'
                user.save

                NOTE: find_by requires .save like .new method
                    OR 

                user = User.find_by(name: 'David')
                user.update(name: 'Dave')

            # updating in bulk
                User.update_all 'max_login_attempts = 3, must_change_password = "true" '

        4. Delete 
                - deleting values from the database row!

                # destroy user with name david (first)
                    user = User.find_by(name: 'David')
                    user.destroy 
                
                # delete all users name David
                    User.where(name: 'David').destroy_all

                # delete all users   (which i will never use)
                    USer.destroy_all
    
    Migrations
        
        # MIGRATIONS used to CUD tables
        # ALTER TABLE in SQL
        # the R - red is performed by the controller/model
        # since that is data retrieval

        Creating Standalone migration 
            # usually do this when you want to
            # do something after table is already made  
            1. Add column 
                AddColumnToTable
                AddXXXToXXX
                    i.e.
                    rails generate migration AddPartNumberToProducts part_number:string
                    generates
                     class AddPartNumberToProducts < ActiveRecord::Migration[5.9]
                        def change
                            add_column :products, :part_number, :string
                        end
                     end
            2. Remove column 
                RemoveColumnFromTable 
                RemoveXXXFromXXX
                    i.e. (can add multiple columns)
                    rails generate migration RemovePartNumberFromProducts part_number:string
                    class RemovePartNumberFromProducts < Active...
                        def change
                            remove_column :products, :part_number, :string
                        end
                    end
            3. Create table 
                CreateTable
                CreateXXX
                    i.e. (creates table)
                    rails generate migration CreateProducts name:string part_number:string
                    class CreateProducts < ActiveRecord::Migration[5.0]
                        def change
                            create_table :products do |t|
                                t.string :name
                                t.string :part_number
                            end
                        end
                    end

            4. DO it one statement
                    change_table 

                    i.e. 
                    
                    change_table :products do |t|
                        t.remove :description, :name
                        t.string :part_number
                        t.index :part_number
                        t.rename :upccode, :upc_code
                    end
                    - remove description and name column
                    - creates part_number string collumn
                    - add an index on part_number column
                    - renames the upccode column
        
        Column Modifiers
            i.e. 
                add_column :products, :price, :decimal, precision: 5, scale: 2
                add_reference :products, :supplier, polymorphic: true
            
            limit       - Sets the maximum size of the string/text/binary/integer fields.
            precision   - Defines the precision for the decimal fields, representing the total number of digits in the number.
            scale       - Defines the scale for the decimal fields, representing the number of digits after the decimal point.
            polymorphic - Adds a type column for belongs_to associations.
            null        - Allows or disallows NULL values in the column.
            default     - Allows to set a default value on the column. Note that if you are using a dynamic value (such as a date), the default will only be calculated the first time (i.e. on the date the migration is applied).
            index       - Adds an index for the column.
            comment     - Adds a comment for the column.

    Migration Methods / Commands 
        1. change
            allows for both the up and down functionality
            - changed from up (adding/migrating to data base)
            - down (Removing/ reversing migration)
                e.g. 
                    def change
                        create_table :distributors do |t|
                            t.string :zipcode 
                        end
                    end

        2. execute
            - allows the input of direct sql in migration file
                e.g. 
                    def up 
                        execute <<-SQL
                            ALTER TABLE distributors
                                ADD CONSTRAINT zipchk
                                    CHECK (char_length(zipcode) = 5) NO INHERIT;
                        SQL
                    end

        3. reversible
                - if active recored doesn't know how to 
                reverse something 
                - you tell it how to implement and reverse it
                
                reversible do |dir|
                    # how to migrate the database
                    dir.up do
                        code to migrate (can be straight sql)
                    end
                    # how to reverse with a rollback or revert
                    dir.down do
                        code to reverse (can be straight sql)
                    end
                end

                e.g. 
                    class ExampleMigration < ActiveRecord::Migration[5.0]
                        def change
                            create_table :distributors do |t|
                            t.string :zipcode
                            end
                        
                            reversible do |dir|
                            dir.up do
                                # add a CHECK constraint
                                execute <<-SQL
                                ALTER TABLE distributors
                                    ADD CONSTRAINT zipchk
                                    CHECK (char_length(zipcode) = 5) NO INHERIT;
                                SQL
                            end
                            dir.down do
                                execute <<-SQL
                                ALTER TABLE distributors
                                    DROP CONSTRAINT zipchk
                                SQL
                            end
                            end
                        
                            add_column :users, :home_page_url, :string
                            rename_column :users, :email, :email_address
                        end
                    end
        4. up VS down
            (old style of migration)
            -UP transforms schema 
            -DOWN revert change to schema
                
                def up
                # add code to migrate 
                end
                
                def down
                # add code to reverse ups migration
                end 

            e.g. 
                def up
                    create_table :distributors do |t|      
                    t.string :zipcode
                    end
                
                    # add a CHECK constraint
                    execute <<-SQL
                    ALTER TABLE distributors
                        ADD CONSTRAINT zipchk
                        CHECK (char_length(zipcode) = 5);
                    SQL
                
                    add_column :users, :home_page_url, :string
                    rename_column :users, :email, :email_address
                end
                    1. create distributors table: with "zipcode" column
                    2. added constraint name "zipchk" to distributors table
                    3. added home_page_url column TO users table 
                    4. renamed email column in users table to email_address

                # should raise error message if someone tries to revert with down
                def down
                    rename_column :users, :email_address, :email
                    remove_column :users, :home_page_url
                
                    execute <<-SQL
                    ALTER TABLE distributors
                        DROP CONSTRAINT zipchk
                    SQL
                
                    drop_table :distributors
                end
                    # did the exact opposite (reverse order)
                    1. renamed email_address column in user back to email 
                    2. removed home_page_url column FROM users table 
                    3. removed constraint name "zipchk" FROM distributors table
                    4. dropped/ deleted distributors table

        6. revert 
                # used to rollback migrations
                
                revert "NameOfMigration"

                e.g. 
                def change 
                    revert CreateProductTableMigration
                end 
                #look back at guide for more details

    Associations
        Model relationships (6)
        1. has_many
            have pluralized terms/class name
                class Author < ApplicationRecord
                    has_many :books
                end
        2. has_one
            must have singular terms/class name
                class Book < ApplicationRecord
                    has_one :author
                end
        3. belongs_to
            must have singular terms/class name
                class Book < ApplicationRecord
                    belongs_to :author
                end
        4. has_and_belongs_to_many
            must have plural terms/class names 
                class Assembly < ApplicationRecord
                    has_and_belongs_to_many :parts
                end
                
                class Part < ApplicationRecord
                    has_and_belongs_to_many :assemblies
                end
        5. has_many :through
            must have pluralization when after :through
                    e.g. 
                    class Physician < ApplicationRecord
                        has_many :appointments
                        has_many :patients, through: :appointments
                    end
                    
                    class Appointment < ApplicationRecord
                        belongs_to :physician
                        belongs_to :patient
                    end
                    
                    class Patient < ApplicationRecord
                        has_many :appointments
                        has_many :physicians, through: :appointments
                    end
        6. has_one :through
            all singular because its has_one and belongs_to
                e.g.
                class Supplier < ApplicationRecord
                    has_one :account
                    has_one :account_history, through: :account
                end
                
                class Account < ApplicationRecord
                    belongs_to :supplier
                    has_one :account_history
                end
                
                class AccountHistory < ApplicationRecord
                    belongs_to :account
                end






*********************************************
SEND EMAIL TO PHILLAPINO PERSON IN AMERICA
***********************************************
look back at 3.2 creating join table if it becomes apparent
that its needed

go through sql and write some 
stuff of that knowledge
creatae sql.txt file in logprogress
